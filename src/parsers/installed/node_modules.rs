//! Parser for Node.js installed packages in node_modules directories
//!
//! This parser scans node_modules directories to extract information about
//! actually installed packages, including:
//!
//! - Package name and version from package.json
//! - Direct dependencies declared by each package
//! - Support for scoped packages (@org/package)
//! - Recursive scanning of nested node_modules (transitive dependencies)
//!
//! # Example
//!
//! ```rust
//! use scanner::parsers::NodeModulesParser;
//! use std::path::Path;
//!
//! let parser = NodeModulesParser;
//! let node_modules = Path::new("/app/node_modules");
//!
//! match parser.parse_installed(node_modules) {
//!     Ok(packages) => {
//!         for pkg in packages {
//!             println!("{} @ {} ({})", pkg.name, pkg.version, pkg.path.display());
//!             for dep in pkg.dependencies {
//!                 println!("  â†’ {} {}", dep.name, dep.version_constraint);
//!             }
//!         }
//!     }
//!     Err(e) => eprintln!("Error: {}", e),
//! }
//! ```

use crate::models::error::ScanError;
use crate::models::{Ecosystem, InstalledPackage};
use serde_json::Value;
use std::fs;
use std::path::Path;

/// Parser for node_modules directories
pub struct NodeModulesParser;

impl NodeModulesParser {
    /// Parse all installed packages in a node_modules directory
    pub fn parse_installed(
        &self,
        node_modules_path: &Path,
    ) -> Result<Vec<InstalledPackage>, ScanError> {
        let mut packages = Vec::new();

        // Read all subdirectories in node_modules
        let entries = fs::read_dir(node_modules_path).map_err(ScanError::Io)?;

        for entry in entries {
            let entry = entry.map_err(ScanError::Io)?;
            let path = entry.path();

            if path.is_dir() {
                let dir_name = entry.file_name();
                let dir_name_str = dir_name.to_string_lossy();

                // Handle scoped packages (@org/package)
                if dir_name_str.starts_with('@') {
                    // This is a scope directory, scan its subdirectories
                    if let Ok(scoped_entries) = fs::read_dir(&path) {
                        for scoped_entry in scoped_entries.flatten() {
                            let scoped_path = scoped_entry.path();
                            if scoped_path.is_dir() {
                                if let Ok(pkg) = self.parse_package(&scoped_path) {
                                    packages.push(pkg);
                                }

                                // Check for nested node_modules
                                let nested_nm = scoped_path.join("node_modules");
                                if nested_nm.exists() {
                                    if let Ok(nested_pkgs) = self.parse_installed(&nested_nm) {
                                        packages.extend(nested_pkgs);
                                    }
                                }
                            }
                        }
                    }
                } else {
                    // Regular package
                    if let Ok(pkg) = self.parse_package(&path) {
                        packages.push(pkg);
                    }

                    // Check for nested node_modules (transitive dependencies)
                    let nested_nm = path.join("node_modules");
                    if nested_nm.exists() {
                        if let Ok(nested_pkgs) = self.parse_installed(&nested_nm) {
                            packages.extend(nested_pkgs);
                        }
                    }
                }
            }
        }

        Ok(packages)
    }

    /// Parse a single package directory
    fn parse_package(&self, package_path: &Path) -> Result<InstalledPackage, ScanError> {
        let package_json_path = package_path.join("package.json");

        if !package_json_path.exists() {
            return Err(ScanError::Parse {
                file: package_json_path.clone(),
                message: "package.json not found".to_string(),
            });
        }

        let content = fs::read_to_string(&package_json_path).map_err(ScanError::Io)?;

        let json: Value = serde_json::from_str(&content).map_err(|e| ScanError::Parse {
            file: package_json_path.clone(),
            message: format!("Failed to parse JSON: {}", e),
        })?;

        // Extract name
        let name = json
            .get("name")
            .and_then(|v| v.as_str())
            .ok_or_else(|| ScanError::Parse {
                file: package_json_path.clone(),
                message: "Missing 'name' field".to_string(),
            })?
            .to_string();

        // Extract version
        let version = json
            .get("version")
            .and_then(|v| v.as_str())
            .unwrap_or("unknown")
            .to_string();

        let mut package =
            InstalledPackage::new(name, version, package_path.to_path_buf(), Ecosystem::Node);

        // Extract dependencies
        if let Some(deps) = json.get("dependencies").and_then(|v| v.as_object()) {
            for (dep_name, dep_version) in deps {
                if let Some(version_str) = dep_version.as_str() {
                    package.add_dependency(dep_name.clone(), version_str.to_string());
                }
            }
        }

        Ok(package)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    #[test]
    fn test_parse_simple_package() {
        let temp_dir = TempDir::new().unwrap();
        let node_modules = temp_dir.path().join("node_modules");
        let react_dir = node_modules.join("react");
        fs::create_dir_all(&react_dir).unwrap();

        let package_json = r#"{
            "name": "react",
            "version": "18.2.0",
            "dependencies": {
                "loose-envify": "^1.1.0"
            }
        }"#;

        fs::write(react_dir.join("package.json"), package_json).unwrap();

        let parser = NodeModulesParser;
        let packages = parser.parse_installed(&node_modules).unwrap();

        assert_eq!(packages.len(), 1);
        assert_eq!(packages[0].name, "react");
        assert_eq!(packages[0].version, "18.2.0");
        assert_eq!(packages[0].dependencies.len(), 1);
        assert_eq!(packages[0].dependencies[0].name, "loose-envify");
        assert_eq!(packages[0].dependencies[0].version_constraint, "^1.1.0");
    }

    #[test]
    fn test_parse_scoped_package() {
        let temp_dir = TempDir::new().unwrap();
        let node_modules = temp_dir.path().join("node_modules");
        let scope_dir = node_modules.join("@babel");
        let core_dir = scope_dir.join("core");
        fs::create_dir_all(&core_dir).unwrap();

        let package_json = r#"{
            "name": "@babel/core",
            "version": "7.22.0"
        }"#;

        fs::write(core_dir.join("package.json"), package_json).unwrap();

        let parser = NodeModulesParser;
        let packages = parser.parse_installed(&node_modules).unwrap();

        assert_eq!(packages.len(), 1);
        assert_eq!(packages[0].name, "@babel/core");
        assert_eq!(packages[0].version, "7.22.0");
    }

    #[test]
    fn test_parse_nested_node_modules() {
        let temp_dir = TempDir::new().unwrap();
        let node_modules = temp_dir.path().join("node_modules");

        // Create parent package
        let react_dir = node_modules.join("react");
        fs::create_dir_all(&react_dir).unwrap();
        fs::write(
            react_dir.join("package.json"),
            r#"{"name": "react", "version": "18.2.0"}"#,
        )
        .unwrap();

        // Create nested node_modules with transitive dependency
        let nested_nm = react_dir.join("node_modules");
        let loose_envify_dir = nested_nm.join("loose-envify");
        fs::create_dir_all(&loose_envify_dir).unwrap();
        fs::write(
            loose_envify_dir.join("package.json"),
            r#"{"name": "loose-envify", "version": "1.4.0"}"#,
        )
        .unwrap();

        let parser = NodeModulesParser;
        let packages = parser.parse_installed(&node_modules).unwrap();

        assert_eq!(packages.len(), 2);
        assert!(packages.iter().any(|p| p.name == "react"));
        assert!(packages.iter().any(|p| p.name == "loose-envify"));
    }

    #[test]
    fn test_parse_multiple_packages() {
        let temp_dir = TempDir::new().unwrap();
        let node_modules = temp_dir.path().join("node_modules");

        // Create multiple packages
        let react_dir = node_modules.join("react");
        fs::create_dir_all(&react_dir).unwrap();
        fs::write(
            react_dir.join("package.json"),
            r#"{"name": "react", "version": "18.2.0"}"#,
        )
        .unwrap();

        let lodash_dir = node_modules.join("lodash");
        fs::create_dir_all(&lodash_dir).unwrap();
        fs::write(
            lodash_dir.join("package.json"),
            r#"{"name": "lodash", "version": "4.17.21"}"#,
        )
        .unwrap();

        let parser = NodeModulesParser;
        let packages = parser.parse_installed(&node_modules).unwrap();

        assert_eq!(packages.len(), 2);
        assert!(packages.iter().any(|p| p.name == "react"));
        assert!(packages.iter().any(|p| p.name == "lodash"));
    }

    #[test]
    fn test_parse_package_without_version() {
        let temp_dir = TempDir::new().unwrap();
        let node_modules = temp_dir.path().join("node_modules");
        let pkg_dir = node_modules.join("test-pkg");
        fs::create_dir_all(&pkg_dir).unwrap();

        let package_json = r#"{"name": "test-pkg"}"#;
        fs::write(pkg_dir.join("package.json"), package_json).unwrap();

        let parser = NodeModulesParser;
        let packages = parser.parse_installed(&node_modules).unwrap();

        assert_eq!(packages.len(), 1);
        assert_eq!(packages[0].name, "test-pkg");
        assert_eq!(packages[0].version, "unknown");
    }
}
