use scanner::models::{DependencyType, Ecosystem, FileType};
use scanner::parsers::lockfile::CargoLockParser;
use scanner::parsers::manifest::CargoTomlParser;
use scanner::parsers::Parser;
use std::path::Path;

#[test]
fn test_parse_cargo_toml() {
    let content = r#"
[package]
name = "test"
version = "0.1.0"

[dependencies]
serde = "1.0"
tokio = { version = "1.32.0", features = ["full"] }

[dev-dependencies]
criterion = "0.5"

[build-dependencies]
cc = "1.0"
"#;

    let parser = CargoTomlParser;
    let result = parser.parse(content, Path::new("Cargo.toml")).unwrap();

    assert_eq!(result.len(), 4);

    let serde = result.iter().find(|d| d.name == "serde");
    assert!(serde.is_some());
    let serde = serde.unwrap();
    assert_eq!(serde.version, "1.0");
    assert_eq!(serde.dep_type, DependencyType::Runtime);
    assert_eq!(serde.ecosystem, Ecosystem::Rust);

    let tokio = result.iter().find(|d| d.name == "tokio");
    assert!(tokio.is_some());
    assert_eq!(tokio.unwrap().version, "1.32.0");

    let criterion = result.iter().find(|d| d.name == "criterion");
    assert!(criterion.is_some());
    assert_eq!(criterion.unwrap().dep_type, DependencyType::Development);

    let cc = result.iter().find(|d| d.name == "cc");
    assert!(cc.is_some());
    assert_eq!(cc.unwrap().dep_type, DependencyType::Build);
}

#[test]
fn test_parse_cargo_toml_fixture() {
    let content = std::fs::read_to_string("tests/fixtures/rust/Cargo.toml").unwrap();

    let parser = CargoTomlParser;
    let result = parser
        .parse(&content, Path::new("tests/fixtures/rust/Cargo.toml"))
        .unwrap();

    assert!(result.len() >= 6);
    assert!(result
        .iter()
        .any(|d| d.name == "serde" && d.dep_type == DependencyType::Runtime));
    assert!(result
        .iter()
        .any(|d| d.name == "tokio" && d.version == "1.32.0"));
    assert!(result
        .iter()
        .any(|d| d.name == "criterion" && d.dep_type == DependencyType::Development));
    assert!(result
        .iter()
        .any(|d| d.name == "cc" && d.dep_type == DependencyType::Build));
}

#[test]
fn test_parse_cargo_lock() {
    let content = r#"
# This file is automatically @generated by Cargo.
version = 3

[[package]]
name = "serde"
version = "1.0.188"
source = "registry+https://github.com/rust-lang/crates.io-index"

[[package]]
name = "tokio"
version = "1.32.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
"#;

    let parser = CargoLockParser;
    let result = parser.parse(content, Path::new("Cargo.lock")).unwrap();

    assert_eq!(result.len(), 2);

    let serde = result.iter().find(|d| d.name == "serde");
    assert!(serde.is_some());
    let serde = serde.unwrap();
    assert_eq!(serde.version, "1.0.188");
    assert_eq!(serde.ecosystem, Ecosystem::Rust);
    assert_eq!(serde.file_type, FileType::Lockfile);

    let tokio = result.iter().find(|d| d.name == "tokio");
    assert!(tokio.is_some());
    assert_eq!(tokio.unwrap().version, "1.32.0");
}

#[test]
fn test_parse_cargo_lock_fixture() {
    let content = std::fs::read_to_string("tests/fixtures/rust/Cargo.lock").unwrap();

    let parser = CargoLockParser;
    let result = parser
        .parse(&content, Path::new("tests/fixtures/rust/Cargo.lock"))
        .unwrap();

    assert_eq!(result.len(), 3);
    assert!(result
        .iter()
        .any(|d| d.name == "serde" && d.version == "1.0.188"));
    assert!(result
        .iter()
        .any(|d| d.name == "tokio" && d.version == "1.32.0"));
    assert!(result
        .iter()
        .any(|d| d.name == "regex" && d.version == "1.10.2"));
}

#[test]
fn test_cargo_toml_parser_metadata() {
    let parser = CargoTomlParser;
    assert_eq!(parser.ecosystem(), Ecosystem::Rust);
    assert_eq!(parser.file_type(), FileType::Manifest);
    assert_eq!(parser.filename(), "Cargo.toml");
}

#[test]
fn test_cargo_lock_parser_metadata() {
    let parser = CargoLockParser;
    assert_eq!(parser.ecosystem(), Ecosystem::Rust);
    assert_eq!(parser.file_type(), FileType::Lockfile);
    assert_eq!(parser.filename(), "Cargo.lock");
}
